<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Collapse into Structure</title>
    <style>
      html, body { height: 100%; margin: 0; }
      body { background: #050608; overflow: hidden; }
      canvas { display: block; }
      /* Optional: subtle text overlay */
      .label {
        position: absolute;
        left: 28px;
        top: 24px;
        color: rgba(245, 247, 255, 0.82);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        letter-spacing: 0.2px;
        font-size: 14px;
        user-select: none;
        pointer-events: none;
      }
      .label strong { font-weight: 600; color: rgba(245, 247, 255, 0.92); }
      .sub {
        margin-top: 6px;
        color: rgba(245, 247, 255, 0.62);
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="label">
      <strong>Structure before interpretation</strong>
      <div class="sub">representation → constraint → geometry</div>
    </div>

    <!-- Three.js from CDN (no build needed) -->
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

      // -----------------------------
      // Config you can tweak fast
      // -----------------------------
      const CONFIG = {
        points: 2200,          // 1000–3000 feels good
        pointSize: 2.2,        // visual size in px (screen-space)
        cloudRadius: 2.2,      // initial chaotic cloud size
        shapeScale: 1.55,      // final shape size
        loopSeconds: 7.0,      // full loop duration
        holdSeconds: 1.0,      // how long to "rest" on final structure
        drift: 0.035,          // subtle motion in chaos phase
        bg: 0x050608,
        // color palette (subtle, not neon)
        colorA: new THREE.Color("#e9eefb"),
        colorB: new THREE.Color("#87a8ff"),
        colorC: new THREE.Color("#6cf2d6"),
      };

      // Reduce motion if user prefers it
      const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;

      // -----------------------------
      // Scene / Camera / Renderer
      // -----------------------------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.bg);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.01,
        100
      );
      camera.position.set(0, 0, 7.2);

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // A parent group so we can rotate the whole system
      const group = new THREE.Group();
      scene.add(group);

      // Soft light (barely)
      const ambient = new THREE.AmbientLight(0xffffff, 0.55);
      scene.add(ambient);

      // -----------------------------
      // Build particle geometry
      // -----------------------------
      const N = CONFIG.points;

      // Positions: we store start (chaos) and target (structure)
      const startPos = new Float32Array(N * 3);
      const targetPos = new Float32Array(N * 3);
      const colors = new Float32Array(N * 3);

      // Random point in a sphere (chaos)
      function randomInSphere(radius) {
        // Rejection sampling
        while (true) {
          const x = (Math.random() * 2 - 1) * radius;
          const y = (Math.random() * 2 - 1) * radius;
          const z = (Math.random() * 2 - 1) * radius;
          if (x*x + y*y + z*z <= radius*radius) return [x,y,z];
        }
      }

      // Target shape: torus knot (looks like “manifold-ish” structure)
      // You can swap this to "sphere" or "helix" later.
      function torusKnotPoint(t, p = 2, q = 3) {
        // Param t in [0, 2π)
        const r = 0.65;
        const x = (2 + r * Math.cos(q * t)) * Math.cos(p * t);
        const y = (2 + r * Math.cos(q * t)) * Math.sin(p * t);
        const z = r * Math.sin(q * t);
        return [x, y, z];
      }

      // Build a “tube” of points around the torus knot path
      function torusKnotCloud(i) {
        const t = (i / N) * Math.PI * 2;
        const [x0, y0, z0] = torusKnotPoint(t, 2, 3);

        // Add small radial noise around the curve to make it feel like a learned manifold
        const angle = Math.random() * Math.PI * 2;
        const rad = (Math.random() ** 0.6) * 0.18; // tighter center
        const nx = Math.cos(angle) * rad;
        const ny = Math.sin(angle) * rad;
        const nz = (Math.random() * 2 - 1) * rad * 0.35;

        return [x0 + nx, y0 + ny, z0 + nz];
      }

      // Color gradient: mostly neutral, hints of teal/blue
      function colorFor(i) {
        const u = i / (N - 1);
        const c = new THREE.Color();
        if (u < 0.55) c.copy(CONFIG.colorA).lerp(CONFIG.colorB, u / 0.55);
        else c.copy(CONFIG.colorB).lerp(CONFIG.colorC, (u - 0.55) / 0.45);
        // Desaturate a bit
        c.lerp(new THREE.Color("#ffffff"), 0.15);
        return c;
      }

      for (let i = 0; i < N; i++) {
        const [sx, sy, sz] = randomInSphere(CONFIG.cloudRadius);
        startPos[i*3+0] = sx;
        startPos[i*3+1] = sy;
        startPos[i*3+2] = sz;

        const [tx, ty, tz] = torusKnotCloud(i);
        targetPos[i*3+0] = tx * CONFIG.shapeScale * 0.55; // normalize torus knot size
        targetPos[i*3+1] = ty * CONFIG.shapeScale * 0.55;
        targetPos[i*3+2] = tz * CONFIG.shapeScale * 0.55;

        const c = colorFor(i);
        colors[i*3+0] = c.r;
        colors[i*3+1] = c.g;
        colors[i*3+2] = c.b;
      }

      const geometry = new THREE.BufferGeometry();
      // We'll mutate "position" each frame
      geometry.setAttribute("position", new THREE.BufferAttribute(startPos.slice(), 3));
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      // Points material (simple + crisp)
      const material = new THREE.PointsMaterial({
        size: CONFIG.pointSize,
        sizeAttenuation: false, // screen-space points
        vertexColors: true,
        transparent: true,
        opacity: 0.92,
        depthWrite: false,
      });

      const points = new THREE.Points(geometry, material);
      group.add(points);

      // -----------------------------
      // Animation helpers
      // -----------------------------
      function clamp01(x) { return Math.max(0, Math.min(1, x)); }

      function easeInOutCubic(t) {
        t = clamp01(t);
        return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
      }

      // Loop timing:
      // - collapse from chaos -> structure (0..A)
      // - hold on structure (A..B)
      // - expand back to chaos (B..1)
      const loop = CONFIG.loopSeconds;
      const hold = CONFIG.holdSeconds;
      // portion of loop dedicated to transition each way
      const trans = Math.max(0.001, (loop - hold) / 2);

      // Subtle mouse rotation
      let targetRotX = 0;
      let targetRotY = 0;
      let currentRotX = 0;
      let currentRotY = 0;

      window.addEventListener("mousemove", (e) => {
        const x = (e.clientX / window.innerWidth) * 2 - 1;
        const y = (e.clientY / window.innerHeight) * 2 - 1;
        targetRotY = x * 0.25;
        targetRotX = -y * 0.18;
      });

      // -----------------------------
      // Render loop
      // -----------------------------
      const posAttr = geometry.getAttribute("position");
      const pos = posAttr.array;

      const start = performance.now();

      function animate() {
        const now = performance.now();
        const tSec = (now - start) / 1000;

        // Rotate smoothly towards mouse target
        currentRotX += (targetRotX - currentRotX) * 0.04;
        currentRotY += (targetRotY - currentRotY) * 0.04;
        group.rotation.x = currentRotX;
        group.rotation.y = currentRotY + tSec * 0.08; // tiny constant drift

        // If reduced motion: just show final structure with minimal movement
        let mix = 1.0;
        if (!prefersReducedMotion) {
          const phase = (tSec % loop);

          if (phase < trans) {
            // collapse
            mix = easeInOutCubic(phase / trans);
          } else if (phase < trans + hold) {
            // hold
            mix = 1.0;
          } else {
            // expand
            const p = (phase - (trans + hold)) / trans;
            mix = 1.0 - easeInOutCubic(p);
          }
        }

        // Update particle positions: interpolate + add subtle chaos drift in early phase
        const driftStrength = (1.0 - mix) * CONFIG.drift;
        const driftTime = tSec * 0.9;

        for (let i = 0; i < N; i++) {
          const ix = i*3;

          const sx = startPos[ix+0];
          const sy = startPos[ix+1];
          const sz = startPos[ix+2];

          const tx = targetPos[ix+0];
          const ty = targetPos[ix+1];
          const tz = targetPos[ix+2];

          // Base interpolation
          let x = sx + (tx - sx) * mix;
          let y = sy + (ty - sy) * mix;
          let z = sz + (tz - sz) * mix;

          // Gentle drift in chaos phase only
          if (driftStrength > 0.00001) {
            const j = i * 0.0017;
            x += Math.sin(driftTime + j * 13.1) * driftStrength;
            y += Math.cos(driftTime * 0.9 + j * 9.7) * driftStrength;
            z += Math.sin(driftTime * 1.1 + j * 7.3) * driftStrength * 0.6;
          }

          pos[ix+0] = x;
          pos[ix+1] = y;
          pos[ix+2] = z;
        }

        posAttr.needsUpdate = true;

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      animate();

      // -----------------------------
      // Resize handling
      // -----------------------------
      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener("resize", onResize);

      // Optional: click toggles pause (handy for screen capture)
      let paused = false;
      window.addEventListener("click", () => {
        paused = !paused;
        if (paused) {
          // crude pause by freezing start offset
          // (simple: just stop rotation drift & mix changes by locking reduced motion)
          // For a real pause, you’d store time offset; this is fine for quick use.
          alert("Tip: If you want a true pause, tell me and I’ll add it cleanly.");
        }
      });
    </script>
  </body>
</html>
